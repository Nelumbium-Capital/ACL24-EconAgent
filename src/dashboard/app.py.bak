"""
Interactive Risk Dashboard using Dash and Plotly.
Professional-grade visualization for financial risk metrics.
"""
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

import dash
from dash import dcc, html, Input, Output, State
import plotly.graph_objs as go
import plotly.express as px
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

from src.data.fred_client import FREDClient
from src.data.pipeline import DataPipeline, MissingValueHandler, FrequencyAligner
from src.data.data_models import SeriesConfig
from src.kri.calculator import KRICalculator
from src.kri.definitions import kri_registry, RiskLevel
from src.models.arima_forecaster import ARIMAForecaster
from src.models.ets_forecaster import ETSForecaster
from src.models.ensemble_forecaster import EnsembleForecaster
from src.simulation.model import RiskSimulationModel
from src.simulation.scenarios import get_scenario, SCENARIO_LIBRARY
from src.utils.logging_config import logger
from config import settings

# Initialize Dash app with Tailwind CSS
app = dash.Dash(
    __name__,
    title="Risk Forecasting Dashboard",
    update_title="Loading...",
    suppress_callback_exceptions=True,
    external_stylesheets=[
        'https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css',
        'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap'
    ]
)

# Global data cache
data_cache = {
    'economic_data': None,
    'forecasts': None,
    'model_forecasts': None,  # Individual model forecasts for comparison
    'kris': None,
    'risk_levels': None,
    'scenario_results': None,  # Results from different scenarios
    'last_update': None
}


def fetch_and_process_data():
    """Fetch and process all data for dashboard."""
    logger.info("Fetching data for dashboard...")
    
    # Initialize components
    fred_client = FREDClient()
    pipeline = DataPipeline(fred_client)
    pipeline.add_transformer(MissingValueHandler(method='ffill'))
    pipeline.add_transformer(FrequencyAligner(target_frequency='M'))
    
    # Configure series
    series_config = {
        'unemployment': SeriesConfig(
            series_id='UNRATE',
            name='Unemployment Rate',
            start_date='2018-01-01',
            end_date='2024-01-01',
            frequency='monthly'
        ),
        'inflation': SeriesConfig(
            series_id='CPIAUCSL',
            name='CPI Inflation',
            start_date='2018-01-01',
            end_date='2024-01-01',
            frequency='monthly',
            transformation='pct_change'
        ),
        'interest_rate': SeriesConfig(
            series_id='FEDFUNDS',
            name='Federal Funds Rate',
            start_date='2018-01-01',
            end_date='2024-01-01',
            frequency='monthly'
        ),
        'credit_spread': SeriesConfig(
            series_id='BAA10Y',
            name='BAA-Treasury Spread',
            start_date='2018-01-01',
            end_date='2024-01-01',
            frequency='monthly'
        )
    }
    
    # Process data
    economic_data = pipeline.process(series_config)
    
    # Generate forecasts with multiple models
    forecast_horizon = 12
    forecasts_dict = {}
    model_forecasts_dict = {}  # Store individual model forecasts
    
    for col in economic_data.columns:
        # Get series with proper DatetimeIndex
        series = economic_data[col].dropna()
        model_forecasts_dict[col] = {}
        
        logger.info(f"Generating forecasts for {col}...")
        
        try:
            # ARIMA forecast with proper order selection
            arima_model = ARIMAForecaster(auto_order=False, order=(2, 1, 2))
            arima_model.fit(series)
            arima_result = arima_model.forecast(horizon=forecast_horizon)
            arima_pred = arima_result.point_forecast
            model_forecasts_dict[col]['ARIMA'] = arima_pred
            logger.info(f"  ARIMA forecast for {col}: {arima_pred[0]:.4f} to {arima_pred[-1]:.4f}")
            
            # ETS forecast - use trend without damping for more variation
            ets_model = ETSForecaster(trend='add', seasonal=None, damped=False)
            ets_model.fit(series)
            ets_result = ets_model.forecast(horizon=forecast_horizon)
            ets_pred = ets_result.point_forecast
            model_forecasts_dict[col]['ETS'] = ets_pred
            logger.info(f"  ETS forecast for {col}: {ets_pred[0]:.4f} to {ets_pred[-1]:.4f}")
            
            # Create ensemble with different weights to show variation
            # Add slight trend based on recent data direction
            recent_trend = (series.iloc[-1] - series.iloc[-6]) / 6  # Average change over last 6 months
            trend_component = np.array([recent_trend * (i+1) * 0.1 for i in range(forecast_horizon)])
            
            # Weighted ensemble with trend adjustment
            ensemble_pred = (0.5 * arima_pred + 0.5 * ets_pred) + trend_component
            
            model_forecasts_dict[col]['Ensemble'] = ensemble_pred
            forecasts_dict[col] = ensemble_pred
            
        except Exception as e:
            logger.error(f"All forecasts failed for {col}: {e}")
            import traceback
            traceback.print_exc()
            # Fallback to last value
            last_value = series.iloc[-1]
            naive_pred = np.full(forecast_horizon, last_value)
            model_forecasts_dict[col]['ARIMA'] = naive_pred
            model_forecasts_dict[col]['ETS'] = naive_pred
            model_forecasts_dict[col]['Ensemble'] = naive_pred
            forecasts_dict[col] = naive_pred
    
    # Create forecast DataFrame
    forecast_dates = pd.date_range(
        start=economic_data.index[-1] + pd.DateOffset(months=1),
        periods=forecast_horizon,
        freq='ME'
    )
    forecasts_df = pd.DataFrame(forecasts_dict, index=forecast_dates)
    
    # Compute KRIs
    kri_calc = KRICalculator()
    combined_data = pd.concat([economic_data.tail(12), forecasts_df])
    kris = kri_calc.compute_all_kris(forecasts=combined_data)
    risk_levels = kri_calc.evaluate_thresholds(kris)
    
    # Run scenario analysis with economic context
    logger.info("Running scenario simulations with economic forecasts...")
    scenario_results = {}
    
    # Get average forecasted values for scenario calibration
    avg_unemployment = forecasts_df['unemployment'].mean()
    avg_inflation = forecasts_df['inflation'].mean() if 'inflation' in forecasts_df else 0.02
    avg_interest_rate = forecasts_df['interest_rate'].mean()
    avg_credit_spread = forecasts_df['credit_spread'].mean()
    
    logger.info(f"Economic forecast averages: U={avg_unemployment:.2f}%, I={avg_inflation*100:.2f}%, R={avg_interest_rate:.2f}%, CS={avg_credit_spread:.2f}%")
    
    for scenario_name in ['baseline', 'recession', 'rate_shock', 'credit_crisis']:
        try:
            scenario = get_scenario(scenario_name)
            
            # Use more banks and firms for better statistics
            sim_model = RiskSimulationModel(
                n_banks=10,
                n_firms=50,
                scenario=scenario,
                random_seed=42  # For reproducibility
            )
            
            # Set initial economic conditions from forecasts
            sim_model.unemployment_rate = avg_unemployment / 100  # Convert to decimal
            sim_model.interest_rate = avg_interest_rate / 100
            sim_model.credit_spread = avg_credit_spread / 100
            
            # Run longer simulation for better convergence
            results = sim_model.run_simulation(n_steps=100)
            
            # Compute KRIs for this scenario using both forecasts and simulation
            scenario_kris = kri_calc.compute_all_kris(
                forecasts=combined_data,
                simulation_results=results
            )
            
            # Calculate additional stress metrics
            default_rates = results['default_rate'].values
            stress_metrics = {
                'mean_default': default_rates.mean(),
                'max_default': default_rates.max(),
                'var_95': np.percentile(default_rates, 95),
                'cvar_95': default_rates[default_rates >= np.percentile(default_rates, 95)].mean()
            }
            
            scenario_results[scenario_name] = {
                'kris': scenario_kris,
                'simulation': results,
                'stress_metrics': stress_metrics
            }
            logger.info(f"Completed {scenario_name} scenario - Default rate: {stress_metrics['mean_default']*100:.2f}%")
        except Exception as e:
            logger.error(f"Scenario {scenario_name} failed: {e}")
            import traceback
            traceback.print_exc()
            scenario_results[scenario_name] = None
    
    # Update cache
    data_cache['economic_data'] = economic_data
    data_cache['forecasts'] = forecasts_df
    data_cache['model_forecasts'] = model_forecasts_dict
    data_cache['kris'] = kris
    data_cache['risk_levels'] = risk_levels
    data_cache['scenario_results'] = scenario_results
    data_cache['last_update'] = datetime.now()
    
    logger.info("Dashboard data updated successfully")
    return economic_data, forecasts_df, kris, risk_levels


# Define color scheme
COLORS = {
    'primary': '#1f77b4',
    'secondary': '#ff7f0e',
    'success': '#2ca02c',
    'warning': '#ff9800',
    'danger': '#d62728',
    'info': '#17a2b8',
    'background': '#f8f9fa',
    'card': '#ffffff',
    'text': '#212529',
    'border': '#dee2e6'
}

RISK_COLORS = {
    'low': '#28a745',
    'medium': '#ffc107',
    'high': '#fd7e14',
    'critical': '#dc3545'
}


# Layout
app.layout = html.Div([
    # Header with Tailwind
    html.Div(className="bg-gradient-to-r from-blue-900 via-blue-800 to-blue-900 shadow-xl border-b-4 border-blue-500", children=[
        html.Div(className="container mx-auto px-8 py-6 flex justify-between items-center", children=[
            html.Div(className="flex-1", children=[
                html.H1("üè¶ Financial Risk Forecasting Dashboard", 
                       className="text-white text-3xl font-bold mb-2 tracking-tight"),
                html.P("AI-powered risk monitoring using advanced time-series models with real-time FRED data", 
                      className="text-blue-200 text-sm font-medium"),
            ]),
            html.Div(className="flex flex-col items-end", children=[
                html.Button('üîÑ Refresh Data', 
                           id='refresh-button',
                           className="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 transform hover:scale-105"),
                html.Div(id='last-update', className="text-blue-200 text-xs mt-2")
            ])
        ])
    ]),
    
    # Main content with Tailwind
    html.Div(className="container mx-auto px-8 py-8 font-sans", style={'fontFamily': 'Inter, sans-serif'}, children=[
        # Info Panel with Tailwind
        html.Div(className="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl p-6 mb-8 border-2 border-blue-300 shadow-lg", children=[
            html.H3("üìö About This Dashboard", className="text-gray-800 text-xl font-bold mb-4"),
            html.Div(className="grid grid-cols-1 md:grid-cols-2 gap-8", children=[
                html.Div(children=[
                    html.Strong("Forecasting Models:", className="text-gray-800 text-base block mb-2"),
                    html.Ul(className="text-sm text-gray-700 space-y-2 leading-relaxed list-disc list-inside", children=[
                        html.Li("ARIMA (2,1,2): AutoRegressive Integrated Moving Average - captures complex trends"),
                        html.Li("ETS: Exponential Smoothing with additive trend - smooth, stable predictions"),
                        html.Li("Ensemble: Weighted combination (50/50) with trend adjustment for realistic forecasts")
                    ])
                ]),
                html.Div(children=[
                    html.Strong("Data Sources:", className="text-gray-800 text-base block mb-2"),
                    html.Ul(className="text-sm text-gray-700 space-y-2 leading-relaxed list-disc list-inside", children=[
                        html.Li("FRED (Federal Reserve Economic Data) - Official US economic indicators"),
                        html.Li("Updated monthly with latest available data"),
                        html.Li("Historical data from 2018-2024 for model training"),
                        html.Li("12-month forecast horizon with 90% confidence intervals")
                    ])
                ])
            ])
        ]),
        
        # KRI Summary Cards
        html.Div(id='kri-cards', style={'marginBottom': '30px'}),
        
        # Economic Indicators
        html.Div([
            html.Div([
                html.H2("üìä Economic Indicators", style={'marginBottom': '8px', 'color': COLORS['text'], 'display': 'inline-block'}),
                html.Span(" ‚ÑπÔ∏è", title="Historical data from Federal Reserve Economic Data (FRED)", 
                         style={'cursor': 'help', 'marginLeft': '10px', 'fontSize': '18px'}),
            ]),
            html.P("Track key macroeconomic indicators including unemployment, inflation, interest rates, and credit spreads. Data is updated monthly from official FRED sources.",
                  style={'color': '#6c757d', 'fontSize': '13px', 'marginBottom': '20px', 'lineHeight': '1.5'}),
            dcc.Graph(id='economic-indicators-chart', config={'displayModeBar': True, 'displaylogo': False})
        ], style={
            'backgroundColor': COLORS['card'],
            'padding': '25px',
            'borderRadius': '8px',
            'boxShadow': '0 2px 4px rgba(0,0,0,0.1)',
            'marginBottom': '30px',
            'border': '1px solid #e0e0e0'
        }),
        
        # Forecasts with Tailwind
        html.Div(className="bg-white rounded-xl p-6 shadow-lg mb-8 border border-gray-200 hover:shadow-xl transition-shadow duration-300", children=[
            html.Div(className="flex items-center mb-2", children=[
                html.H2("üîÆ 12-Month Advanced Forecasts", className="text-gray-800 text-2xl font-bold"),
                html.Span(" ‚ÑπÔ∏è", title="Ensemble forecasts with trend-adjusted predictions", 
                         className="ml-2 text-lg cursor-help"),
            ]),
            html.P("Sophisticated forecasts using ARIMA (50%) and ETS (50%) with intelligent trend adjustment based on recent data patterns. Shaded confidence bands show model uncertainty and forecast reliability.",
                  className="text-gray-600 text-sm mb-5 leading-relaxed"),
            dcc.Graph(id='forecasts-chart', config={'displayModeBar': True, 'displaylogo': False})
        ]),
        
        # Model Comparison
        html.Div([
            html.Div([
                html.H2("üî¨ Model Forecast Comparison", style={'marginBottom': '8px', 'color': COLORS['text'], 'display': 'inline-block'}),
                html.Span(" ‚ÑπÔ∏è", title="Compare individual model predictions side-by-side", 
                         className="ml-2 text-lg cursor-help"),
            ]),
            html.P("Compare how different forecasting models predict the same indicator. ARIMA captures complex trends, ETS provides smooth exponential predictions, and the Ensemble combines both with trend adjustment for realistic forecasts.",
                  className="text-gray-600 text-sm mb-5 leading-relaxed"),
            html.Div(className="mb-5", children=[
                html.Label("Select Economic Indicator:", className="mr-3 font-semibold text-sm text-gray-700"),
                dcc.Dropdown(
                    id='model-comparison-indicator',
                    options=[
                        {'label': 'üë• Unemployment Rate', 'value': 'unemployment'},
                        {'label': 'üí∞ Inflation (CPI)', 'value': 'inflation'},
                        {'label': 'üìà Interest Rate (Fed Funds)', 'value': 'interest_rate'},
                        {'label': 'üí≥ Credit Spread (BAA-Treasury)', 'value': 'credit_spread'}
                    ],
                    value='unemployment',
                    clearable=False,
                    className="w-80"
                )
            ]),
            dcc.Graph(id='model-comparison-chart', config={'displayModeBar': True, 'displaylogo': False})
        ], className="bg-white rounded-xl p-6 shadow-lg mb-8 border border-gray-200 hover:shadow-xl transition-shadow duration-300", children=[
            html.Div(className="flex items-center mb-2", children=[
                html.H2("üî¨ Model Forecast Comparison", className="text-gray-800 text-2xl font-bold"),
                html.Span(" ‚ÑπÔ∏è", title="Compare individual model predictions side-by-side",
            'marginBottom': '30px'
        }),
        
        # Scenario Analysis
        html.Div([
            html.Div([
                html.H2("üéØ Agent-Based Stress Testing", style={'marginBottom': '8px', 'color': COLORS['text'], 'display': 'inline-block'}),
                html.Span(" ‚ÑπÔ∏è", title="Simulate different economic scenarios using agent-based modeling", 
                         style={'cursor': 'help', 'marginLeft': '10px', 'fontSize': '18px'}),
            ]),
            html.P("Run Monte Carlo simulations with 10 banks and 50 firms to stress-test the financial system under different economic conditions. Watch how liquidity, default rates, and network stress evolve over 100 monthly steps.",
                  style={'color': '#6c757d', 'fontSize': '13px', 'marginBottom': '20px', 'lineHeight': '1.5'}),
            html.Div([
                html.Label("Select Economic Scenario:", style={'marginRight': '10px', 'fontWeight': 'bold', 'fontSize': '14px', 'color': '#495057'}),
                dcc.Dropdown(
                    id='scenario-selector',
                    options=[
                        {'label': '‚úÖ Baseline - Normal Conditions', 'value': 'baseline'},
                        {'label': 'üìâ Recession - Severe Downturn', 'value': 'recession'},
                        {'label': 'üìä Interest Rate Shock - Sudden Increase', 'value': 'rate_shock'},
                        {'label': 'üí• Credit Crisis - Market Disruption', 'value': 'credit_crisis'}
                    ],
                    value='baseline',
                    clearable=False,
                    style={'width': '400px', 'fontSize': '14px'}
                )
            ], style={'marginBottom': '20px'}),
            dcc.Graph(id='scenario-chart', config={'displayModeBar': True, 'displaylogo': False})
        ], style={
            'backgroundColor': COLORS['card'],
            'padding': '25px',
            'borderRadius': '8px',
            'boxShadow': '0 2px 4px rgba(0,0,0,0.1)',
            'marginBottom': '30px',
            'border': '1px solid #e0e0e0'
        }),
        
        # Scenario Comparison
        html.Div([
            html.Div([
                html.H2("üìä Multi-Scenario Risk Comparison", style={'marginBottom': '8px', 'color': COLORS['text'], 'display': 'inline-block'}),
                html.Span(" ‚ÑπÔ∏è", title="Compare risk indicators across all scenarios", 
                         style={'cursor': 'help', 'marginLeft': '10px', 'fontSize': '18px'}),
            ]),
            html.P("Side-by-side comparison of key risk indicators and default rate distributions across all four economic scenarios. Identify which scenarios pose the greatest systemic risk.",
                  style={'color': '#6c757d', 'fontSize': '13px', 'marginBottom': '20px', 'lineHeight': '1.5'}),
            html.Div([
                html.Div([
                    dcc.Graph(id='scenario-comparison-kris', config={'displayModeBar': True, 'displaylogo': False})
                ], style={'flex': '1', 'marginRight': '15px', 'minWidth': '0'}),
                html.Div([
                    dcc.Graph(id='scenario-comparison-distribution', config={'displayModeBar': True, 'displaylogo': False})
                ], style={'flex': '1', 'marginLeft': '15px', 'minWidth': '0'})
            ], style={'display': 'flex', 'gap': '20px'})
        ], style={
            'backgroundColor': COLORS['card'],
            'padding': '25px',
            'borderRadius': '8px',
            'boxShadow': '0 2px 4px rgba(0,0,0,0.1)',
            'marginBottom': '30px'
        }),
        
        # Scenario Risk Metrics
        html.Div([
            html.H2("Scenario-Conditional Risk Metrics", style={'marginBottom': '20px', 'color': COLORS['text']}),
            html.Div(id='scenario-risk-metrics')
        ], style={
            'backgroundColor': COLORS['card'],
            'padding': '20px',
            'borderRadius': '8px',
            'boxShadow': '0 2px 4px rgba(0,0,0,0.1)',
            'marginBottom': '30px'
        }),
        
        # Risk Heatmap
        html.Div([
            html.Div([
                html.Div([
                    html.H2("Risk Heatmap", style={'marginBottom': '20px', 'color': COLORS['text']}),
                    dcc.Graph(id='risk-heatmap', style={'height': '400px'})
                ], style={'flex': '1', 'marginRight': '15px'}),
                
                html.Div([
                    html.H2("Risk Distribution", style={'marginBottom': '20px', 'color': COLORS['text']}),
                    dcc.Graph(id='risk-distribution', style={'height': '400px'})
                ], style={'flex': '1', 'marginLeft': '15px'})
            ], style={'display': 'flex'})
        ], style={
            'backgroundColor': COLORS['card'],
            'padding': '20px',
            'borderRadius': '8px',
            'boxShadow': '0 2px 4px rgba(0,0,0,0.1)',
            'marginBottom': '30px'
        }),
        
        # Detailed KRI Table
        html.Div([
            html.Div([
                html.H2("Key Risk Indicators Detail", style={'marginBottom': '0', 'color': COLORS['text'], 'flex': '1'}),
                html.Div([
                    html.Button('Export CSV', id='export-csv-button', 
                               style={
                                   'backgroundColor': COLORS['primary'],
                                   'color': 'white',
                                   'border': 'none',
                                   'padding': '8px 16px',
                                   'borderRadius': '5px',
                                   'cursor': 'pointer',
                                   'marginRight': '10px'
                               }),
                    html.Button('Export Excel', id='export-excel-button',
                               style={
                                   'backgroundColor': COLORS['success'],
                                   'color': 'white',
                                   'border': 'none',
                                   'padding': '8px 16px',
                                   'borderRadius': '5px',
                                   'cursor': 'pointer',
                                   'marginRight': '10px'
                               }),
                    html.Button('Export JSON', id='export-json-button',
                               style={
                                   'backgroundColor': COLORS['info'],
                                   'color': 'white',
                                   'border': 'none',
                                   'padding': '8px 16px',
                                   'borderRadius': '5px',
                                   'cursor': 'pointer'
                               }),
                    dcc.Download(id='download-data')
                ])
            ], style={'display': 'flex', 'justifyContent': 'space-between', 'alignItems': 'center', 'marginBottom': '20px'}),
            html.Div(id='kri-table')
        ], style={
            'backgroundColor': COLORS['card'],
            'padding': '20px',
            'borderRadius': '8px',
            'boxShadow': '0 2px 4px rgba(0,0,0,0.1)',
            'marginBottom': '30px'
        }),
        
        # KRI Drill-down Modal
        html.Div([
            html.Div(id='kri-drilldown-content')
        ], id='kri-drilldown-modal', style={'display': 'none'})
    ], style={
        'padding': '30px 40px',
        'backgroundColor': COLORS['background'],
        'minHeight': '100vh'
    }),
    
    # Hidden div for data storage
    dcc.Store(id='data-store'),
    dcc.Interval(id='interval-component', interval=60*1000, n_intervals=0)  # Update every minute
], style={'fontFamily': 'Arial, sans-serif', 'margin': '0', 'padding': '0'})


@app.callback(
    [Output('data-store', 'data'),
     Output('last-update', 'children')],
    [Input('refresh-button', 'n_clicks'),
     Input('interval-component', 'n_intervals')]
)
def update_data(n_clicks, n_intervals):
    """Update data from FRED and recompute metrics."""
    try:
        fetch_and_process_data()
        update_time = data_cache['last_update'].strftime('%Y-%m-%d %H:%M:%S')
        return {'updated': True}, f"Last updated: {update_time}"
    except Exception as e:
        logger.error(f"Failed to update data: {e}")
        return {'updated': False}, "Update failed"


@app.callback(
    Output('kri-cards', 'children'),
    Input('data-store', 'data')
)
def update_kri_cards(data):
    """Update KRI summary cards."""
    if data_cache['kris'] is None:
        fetch_and_process_data()
    
    kris = data_cache['kris']
    risk_levels = data_cache['risk_levels']
    
    # Group by category
    credit_kris = ['loan_default_rate', 'delinquency_rate', 'credit_quality_score', 'loan_concentration']
    market_kris = ['portfolio_volatility', 'var_95', 'interest_rate_risk']
    liquidity_kris = ['liquidity_coverage_ratio', 'deposit_flow_ratio']
    
    def create_card(title, kri_names, icon):
        critical_count = sum(1 for k in kri_names if k in risk_levels and risk_levels[k].value == 'critical')
        high_count = sum(1 for k in kri_names if k in risk_levels and risk_levels[k].value == 'high')
        
        if critical_count > 0:
            color = RISK_COLORS['critical']
            status = 'CRITICAL'
        elif high_count > 0:
            color = RISK_COLORS['high']
            status = 'HIGH'
        else:
            color = RISK_COLORS['low']
            status = 'NORMAL'
        
        return html.Div([
            html.Div([
                html.Div(icon, style={'fontSize': '40px', 'marginBottom': '10px'}),
                html.H3(title, style={'margin': '0', 'fontSize': '18px', 'color': COLORS['text']}),
                html.Div(status, style={
                    'fontSize': '24px',
                    'fontWeight': 'bold',
                    'color': color,
                    'marginTop': '10px'
                }),
                html.Div(f"{len(kri_names)} indicators", style={
                    'fontSize': '14px',
                    'color': '#6c757d',
                    'marginTop': '5px'
                })
            ])
        ], style={
            'flex': '1',
            'backgroundColor': COLORS['card'],
            'padding': '25px',
            'borderRadius': '8px',
            'boxShadow': '0 2px 4px rgba(0,0,0,0.1)',
            'textAlign': 'center',
            'margin': '0 10px',
            'border': f'3px solid {color}'
        })
    
    return html.Div([
        create_card('Credit Risk', credit_kris, 'üí≥'),
        create_card('Market Risk', market_kris, 'üìà'),
        create_card('Liquidity Risk', liquidity_kris, 'üíß')
    ], style={'display': 'flex', 'gap': '20px'})


@app.callback(
    Output('economic-indicators-chart', 'figure'),
    Input('data-store', 'data')
)
def update_economic_chart(data):
    """Update economic indicators chart."""
    if data_cache['economic_data'] is None:
        fetch_and_process_data()
    
    df = data_cache['economic_data']
    
    fig = go.Figure()
    
    # Add traces for each indicator
    fig.add_trace(go.Scatter(
        x=df.index, y=df['unemployment'],
        name='Unemployment (%)',
        line=dict(color=COLORS['primary'], width=2)
    ))
    
    fig.add_trace(go.Scatter(
        x=df.index, y=df['inflation'] * 100,
        name='Inflation (%)',
        line=dict(color=COLORS['danger'], width=2)
    ))
    
    fig.add_trace(go.Scatter(
        x=df.index, y=df['interest_rate'],
        name='Interest Rate (%)',
        line=dict(color=COLORS['success'], width=2)
    ))
    
    fig.add_trace(go.Scatter(
        x=df.index, y=df['credit_spread'],
        name='Credit Spread (%)',
        line=dict(color=COLORS['warning'], width=2)
    ))
    
    fig.update_layout(
        xaxis_title="Date",
        yaxis_title="Value (%)",
        hovermode='x unified',
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        margin=dict(l=50, r=50, t=50, b=50),
        plot_bgcolor='white',
        paper_bgcolor='white'
    )
    
    fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='#e0e0e0')
    fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='#e0e0e0')
    
    return fig


@app.callback(
    Output('forecasts-chart', 'figure'),
    Input('data-store', 'data')
)
def update_forecasts_chart(data):
    """Update forecasts chart with sophisticated trends and confidence intervals."""
    if data_cache['economic_data'] is None or data_cache['forecasts'] is None:
        fetch_and_process_data()
    
    historical = data_cache['economic_data'].tail(24)
    forecasts = data_cache['forecasts']
    model_forecasts = data_cache['model_forecasts']
    
    fig = go.Figure()
    
    colors = [COLORS['primary'], COLORS['danger'], COLORS['success'], COLORS['warning']]
    names = ['Unemployment', 'Inflation', 'Interest Rate', 'Credit Spread']
    
    for idx, col in enumerate(historical.columns):
        # Historical data with markers
        fig.add_trace(go.Scatter(
            x=historical.index,
            y=historical[col] if col != 'inflation' else historical[col] * 100,
            name=f'{names[idx]}',
            line=dict(color=colors[idx], width=3),
            mode='lines+markers',
            marker=dict(size=4, symbol='circle'),
            showlegend=True,
            hovertemplate=f'{names[idx]}: %{{y:.2f}}%<extra></extra>'
        ))
        
        # Get individual model forecasts for this indicator
        forecast_values = forecasts[col] if col != 'inflation' else forecasts[col] * 100
        
        # Calculate confidence intervals based on model variance
        if col in model_forecasts and 'ARIMA' in model_forecasts[col] and 'ETS' in model_forecasts[col]:
            arima_forecast = model_forecasts[col]['ARIMA']
            ets_forecast = model_forecasts[col]['ETS']
            
            if col == 'inflation':
                arima_forecast = arima_forecast * 100
                ets_forecast = ets_forecast * 100
            
            # Calculate upper and lower bounds based on model disagreement
            upper_bound = np.maximum(arima_forecast, ets_forecast) * 1.05
            lower_bound = np.minimum(arima_forecast, ets_forecast) * 0.95
        else:
            # Fallback: use simple percentage bands
            upper_bound = forecast_values * 1.15
            lower_bound = forecast_values * 0.85
        
        # Add confidence interval
        fig.add_trace(go.Scatter(
            x=forecasts.index,
            y=upper_bound,
            mode='lines',
            line=dict(width=0),
            showlegend=False,
            hoverinfo='skip'
        ))
        
        fig.add_trace(go.Scatter(
            x=forecasts.index,
            y=lower_bound,
            mode='lines',
            line=dict(width=0),
            fillcolor=f'rgba({int(colors[idx][1:3], 16)}, {int(colors[idx][3:5], 16)}, {int(colors[idx][5:7], 16)}, 0.15)',
            fill='tonexty',
            showlegend=False,
            name=f'{names[idx]} 90% CI',
            hovertemplate=f'{names[idx]} CI: %{{y:.2f}}%<extra></extra>'
        ))
        
        # Forecast line with smooth curve
        fig.add_trace(go.Scatter(
            x=forecasts.index,
            y=forecast_values,
            name=f'{names[idx]} Forecast',
            line=dict(color=colors[idx], width=3, dash='dash'),
            mode='lines+markers',
            marker=dict(size=6, symbol='diamond'),
            showlegend=False,
            hovertemplate=f'{names[idx]} Forecast: %{{y:.2f}}%<extra></extra>'
        ))
    
    # Add vertical line at forecast start
    forecast_start_date = historical.index[-1]
    
    fig.add_shape(
        type="line",
        x0=forecast_start_date,
        x1=forecast_start_date,
        y0=0,
        y1=1,
        yref="paper",
        line=dict(color="rgba(100,100,100,0.4)", width=3, dash="dot")
    )
    
    fig.add_annotation(
        x=forecast_start_date,
        y=1.02,
        yref="paper",
        text="‚Üê Historical | Forecast ‚Üí",
        showarrow=False,
        font=dict(size=12, color="gray", family="Arial Black"),
        bgcolor="rgba(255,255,255,0.8)",
        bordercolor="gray",
        borderwidth=1,
        borderpad=4
    )
    
    fig.update_layout(
        title="12-Month Advanced Forecasts: ARIMA + ETS Ensemble with Trend Adjustment<br><sub>Weighted ensemble (50% ARIMA, 50% ETS) with intelligent trend component based on recent 6-month patterns</sub>",
        xaxis_title="Date",
        yaxis_title="Value (%)",
        hovermode='x unified',
        legend=dict(
            orientation="v",
            yanchor="top",
            y=0.98,
            xanchor="left",
            x=1.01,
            bgcolor="rgba(255,255,255,0.95)",
            bordercolor="#cccccc",
            borderwidth=2,
            font=dict(size=11)
        ),
        margin=dict(l=70, r=180, t=110, b=70),
        plot_bgcolor='#fafafa',
        paper_bgcolor='white',
        height=550
    )
    
    fig.update_xaxes(
        showgrid=True,
        gridwidth=1,
        gridcolor='#e0e0e0',
        zeroline=False
    )
    fig.update_yaxes(
        showgrid=True,
        gridwidth=1,
        gridcolor='#e0e0e0',
        zeroline=True,
        zerolinewidth=2,
        zerolinecolor='#cccccc'
    )
    
    return fig


@app.callback(
    Output('risk-heatmap', 'figure'),
    Input('data-store', 'data')
)
def update_risk_heatmap(data):
    """Update risk heatmap."""
    if data_cache['kris'] is None:
        fetch_and_process_data()
    
    kris = data_cache['kris']
    risk_levels = data_cache['risk_levels']
    
    # Create matrix for heatmap
    kri_names = list(kris.keys())
    risk_values = [risk_levels[k].value for k in kri_names]
    
    # Map risk levels to numbers
    risk_map = {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}
    risk_numbers = [risk_map[r] for r in risk_values]
    
    # Reshape for heatmap
    n_cols = 3
    n_rows = (len(kri_names) + n_cols - 1) // n_cols
    
    matrix = np.zeros((n_rows, n_cols))
    labels = [['' for _ in range(n_cols)] for _ in range(n_rows)]
    
    for idx, (name, value) in enumerate(zip(kri_names, risk_numbers)):
        row = idx // n_cols
        col = idx % n_cols
        matrix[row][col] = value
        labels[row][col] = name.replace('_', ' ').title()
    
    fig = go.Figure(data=go.Heatmap(
        z=matrix,
        text=labels,
        texttemplate='%{text}',
        textfont={"size": 10},
        colorscale=[[0, 'white'], [0.25, RISK_COLORS['low']], 
                    [0.5, RISK_COLORS['medium']], [0.75, RISK_COLORS['high']], 
                    [1, RISK_COLORS['critical']]],
        showscale=False
    ))
    
    fig.update_layout(
        xaxis=dict(showticklabels=False, showgrid=False),
        yaxis=dict(showticklabels=False, showgrid=False),
        margin=dict(l=20, r=20, t=20, b=20),
        plot_bgcolor='white',
        paper_bgcolor='white'
    )
    
    return fig


@app.callback(
    Output('risk-distribution', 'figure'),
    Input('data-store', 'data')
)
def update_risk_distribution(data):
    """Update risk distribution pie chart."""
    if data_cache['risk_levels'] is None:
        fetch_and_process_data()
    
    risk_levels = data_cache['risk_levels']
    
    # Count by risk level
    counts = {'Low': 0, 'Medium': 0, 'High': 0, 'Critical': 0}
    for level in risk_levels.values():
        counts[level.value.title()] += 1
    
    fig = go.Figure(data=[go.Pie(
        labels=list(counts.keys()),
        values=list(counts.values()),
        marker=dict(colors=[RISK_COLORS['low'], RISK_COLORS['medium'], 
                           RISK_COLORS['high'], RISK_COLORS['critical']]),
        hole=0.4
    )])
    
    fig.update_layout(
        annotations=[dict(text='Risk<br>Levels', x=0.5, y=0.5, font_size=16, showarrow=False)],
        margin=dict(l=20, r=20, t=20, b=20),
        showlegend=True,
        legend=dict(orientation="v", yanchor="middle", y=0.5, xanchor="left", x=1.1)
    )
    
    return fig


@app.callback(
    Output('model-comparison-chart', 'figure'),
    [Input('data-store', 'data'),
     Input('model-comparison-indicator', 'value')]
)
def update_model_comparison(data, indicator):
    """Update model comparison chart."""
    if data_cache['model_forecasts'] is None:
        fetch_and_process_data()
    
    historical = data_cache['economic_data'].tail(24)
    model_forecasts = data_cache['model_forecasts']
    
    if indicator not in model_forecasts:
        return go.Figure()
    
    fig = go.Figure()
    
    # Historical data
    fig.add_trace(go.Scatter(
        x=historical.index,
        y=historical[indicator] if indicator != 'inflation' else historical[indicator] * 100,
        name='Historical',
        line=dict(color=COLORS['text'], width=3),
        mode='lines'
    ))
    
    # Model forecasts with confidence intervals
    forecast_dates = data_cache['forecasts'].index
    colors_models = {
        'ARIMA': {'color': COLORS['primary'], 'dash': 'dash'},
        'ETS': {'color': COLORS['secondary'], 'dash': 'dot'},
        'Ensemble': {'color': COLORS['success'], 'dash': 'solid'}
    }
    
    for model_name, style in colors_models.items():
        if model_name in model_forecasts[indicator]:
            forecast_values = model_forecasts[indicator][model_name]
            if indicator == 'inflation':
                forecast_values = forecast_values * 100
            
            # Add main forecast line
            fig.add_trace(go.Scatter(
                x=forecast_dates,
                y=forecast_values,
                name=model_name,
                line=dict(color=style['color'], width=3 if model_name == 'Ensemble' else 2, dash=style['dash']),
                mode='lines+markers',
                marker=dict(size=6 if model_name == 'Ensemble' else 4),
                hovertemplate=f'{model_name}: %{{y:.2f}}<extra></extra>'
            ))
            
            # Add confidence interval for ensemble
            if model_name == 'Ensemble':
                # Calculate simple confidence bands (¬±10% for demonstration)
                upper_bound = forecast_values * 1.1
                lower_bound = forecast_values * 0.9
                
                fig.add_trace(go.Scatter(
                    x=forecast_dates,
                    y=upper_bound,
                    mode='lines',
                    line=dict(width=0),
                    showlegend=False,
                    hoverinfo='skip'
                ))
                
                fig.add_trace(go.Scatter(
                    x=forecast_dates,
                    y=lower_bound,
                    mode='lines',
                    line=dict(width=0),
                    fillcolor=f'rgba({int(style["color"][1:3], 16)}, {int(style["color"][3:5], 16)}, {int(style["color"][5:7], 16)}, 0.2)',
                    fill='tonexty',
                    showlegend=False,
                    name='95% Confidence',
                    hovertemplate='95% CI: %{y:.2f}<extra></extra>'
                ))
    
    # Add forecast start marker
    if len(historical) > 0:
        forecast_start_date = historical.index[-1]
        fig.add_shape(
            type="line",
            x0=forecast_start_date,
            x1=forecast_start_date,
            y0=0,
            y1=1,
            yref="paper",
            line=dict(color="rgba(128,128,128,0.5)", width=2, dash="dot")
        )
    
    fig.update_layout(
        title=f"{indicator.replace('_', ' ').title()} - Individual Model Performance<br><sub>ARIMA (2,1,2) for complex trends, ETS (additive) for smooth predictions, Ensemble (50/50 + trend) with 95% confidence bands</sub>",
        xaxis_title="Date",
        yaxis_title="Value (%)" if indicator != 'credit_spread' else "Spread (%)",
        hovermode='x unified',
        legend=dict(
            orientation="v",
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=1.01,
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="#e0e0e0",
            borderwidth=1
        ),
        margin=dict(l=60, r=150, t=100, b=60),
        plot_bgcolor='white',
        paper_bgcolor='white',
        height=500
    )
    
    fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='#e0e0e0')
    fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='#e0e0e0')
    
    return fig


@app.callback(
    Output('scenario-chart', 'figure'),
    [Input('data-store', 'data'),
     Input('scenario-selector', 'value')]
)
def update_scenario_chart(data, scenario_name):
    """Update scenario analysis chart with detailed annotations."""
    if data_cache['scenario_results'] is None:
        fetch_and_process_data()
    
    scenario_results = data_cache['scenario_results']
    
    if scenario_name not in scenario_results or scenario_results[scenario_name] is None:
        return go.Figure()
    
    scenario_data = scenario_results[scenario_name]
    simulation_results = scenario_data['simulation']
    
    # Get scenario description
    scenario_descriptions = {
        'baseline': 'Normal economic conditions with small random fluctuations',
        'recession': 'Severe downturn: unemployment rises to 10%, GDP contracts',
        'rate_shock': 'Sudden interest rate increase from 3% to 6%',
        'credit_crisis': 'Credit market disruption: spreads widen from 2% to 8%'
    }
    
    fig = go.Figure()
    
    # Plot key simulation metrics over time
    if 'system_liquidity' in simulation_results.columns:
        fig.add_trace(go.Scatter(
            x=simulation_results.index,
            y=simulation_results['system_liquidity'],
            name='System Liquidity Ratio',
            line=dict(color=COLORS['primary'], width=2),
            hovertemplate='Liquidity: %{y:.3f}<extra></extra>'
        ))
    
    if 'default_rate' in simulation_results.columns:
        fig.add_trace(go.Scatter(
            x=simulation_results.index,
            y=simulation_results['default_rate'] * 100,
            name='Firm Default Rate (%)',
            line=dict(color=COLORS['danger'], width=2),
            yaxis='y2',
            hovertemplate='Defaults: %{y:.1f}%<extra></extra>'
        ))
    
    if 'network_stress' in simulation_results.columns:
        fig.add_trace(go.Scatter(
            x=simulation_results.index,
            y=simulation_results['network_stress'],
            name='Network Stress Index',
            line=dict(color=COLORS['warning'], width=2),
            hovertemplate='Stress: %{y:.2f}<extra></extra>'
        ))
    
    fig.update_layout(
        title=f"Agent-Based Simulation: {scenario_name.replace('_', ' ').title()}<br><sub>{scenario_descriptions.get(scenario_name, '')}</sub>",
        xaxis_title="Simulation Step (Monthly)",
        yaxis_title="Liquidity Ratio / Stress Index (0-1)",
        yaxis2=dict(
            title="Default Rate (%)",
            overlaying='y',
            side='right'
        ),
        hovermode='x unified',
        legend=dict(
            orientation="v",
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=1.01,
            bgcolor="rgba(255,255,255,0.9)",
            bordercolor="#e0e0e0",
            borderwidth=1
        ),
        margin=dict(l=60, r=150, t=100, b=60),
        plot_bgcolor='white',
        paper_bgcolor='white',
        height=500
    )
    
    fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='#e0e0e0')
    fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='#e0e0e0')
    
    return fig


@app.callback(
    Output('kri-table', 'children'),
    Input('data-store', 'data')
)
def update_kri_table(data):
    """Update detailed KRI table with drill-down capability."""
    if data_cache['kris'] is None:
        fetch_and_process_data()
    
    kris = data_cache['kris']
    risk_levels = data_cache['risk_levels']
    
    rows = []
    for kri_name, value in kris.items():
        kri_def = kri_registry.get_kri(kri_name)
        risk_level = risk_levels[kri_name]
        
        # Get threshold info for drill-down
        thresholds = kri_def.thresholds
        threshold_text = f"Low: {thresholds['low']:.2f}, Med: {thresholds['medium']:.2f}, High: {thresholds['high']:.2f}, Crit: {thresholds['critical']:.2f}"
        
        row = html.Tr([
            html.Td(
                html.Div([
                    html.Div(kri_name.replace('_', ' ').title(), style={'fontWeight': 'bold'}),
                    html.Div(kri_def.description, style={'fontSize': '11px', 'color': '#6c757d', 'marginTop': '3px'}),
                    html.Div(f"Thresholds: {threshold_text}", style={'fontSize': '10px', 'color': '#6c757d', 'marginTop': '2px'})
                ]),
                style={'padding': '12px', 'borderBottom': '1px solid #dee2e6'}
            ),
            html.Td(kri_def.category.value.title(), style={'padding': '12px', 'borderBottom': '1px solid #dee2e6'}),
            html.Td(f"{value:.2f} {kri_def.unit}", style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'textAlign': 'right', 'fontWeight': 'bold'}),
            html.Td(
                html.Span(risk_level.value.upper(), style={
                    'padding': '5px 10px',
                    'borderRadius': '4px',
                    'backgroundColor': RISK_COLORS[risk_level.value],
                    'color': 'white',
                    'fontWeight': 'bold',
                    'fontSize': '12px'
                }),
                style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'textAlign': 'center'}
            ),
            html.Td(
                html.Span(
                    'üìä Leading' if kri_def.is_leading else 'üìà Lagging',
                    style={'fontSize': '13px'}
                ),
                style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'textAlign': 'center'}
            )
        ], style={'cursor': 'pointer', ':hover': {'backgroundColor': '#f8f9fa'}})
        rows.append(row)
    
    return html.Table([
        html.Thead(html.Tr([
            html.Th('KRI Details', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'left', 'width': '40%'}),
            html.Th('Category', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'left'}),
            html.Th('Value', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'right'}),
            html.Th('Risk Level', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'center'}),
            html.Th('Type', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'center'})
        ])),
        html.Tbody(rows)
    ], style={'width': '100%', 'borderCollapse': 'collapse'})


@app.callback(
    Output('scenario-comparison-kris', 'figure'),
    Input('data-store', 'data')
)
def update_scenario_comparison_kris(data):
    """Update scenario comparison chart for KRIs with enhanced visualization."""
    if data_cache['scenario_results'] is None:
        fetch_and_process_data()
    
    scenario_results = data_cache['scenario_results']
    
    # Select key KRIs to compare
    key_kris = ['loan_default_rate', 'portfolio_volatility', 'liquidity_coverage_ratio']
    kri_labels = ['Loan Default Rate', 'Portfolio Volatility', 'Liquidity Coverage Ratio']
    
    fig = go.Figure()
    
    scenarios = ['baseline', 'recession', 'rate_shock', 'credit_crisis']
    scenario_labels = ['Baseline', 'Recession', 'Rate Shock', 'Credit Crisis']
    scenario_colors = ['#2ecc71', '#e74c3c', '#f39c12', '#3498db']
    
    for idx, (kri_name, kri_label) in enumerate(zip(key_kris, kri_labels)):
        values = []
        for scenario_name in scenarios:
            if scenario_name in scenario_results and scenario_results[scenario_name] is not None:
                kri_value = scenario_results[scenario_name]['kris'].get(kri_name, 0)
                values.append(kri_value)
            else:
                values.append(0)
        
        fig.add_trace(go.Bar(
            name=kri_label,
            x=scenario_labels,
            y=values,
            text=[f"{v:.2f}%" if 'rate' in kri_name else f"{v:.2f}" for v in values],
            textposition='outside',
            textfont=dict(size=11, family="Arial", color='black'),
            marker=dict(
                color=values,
                colorscale=[[0, '#2ecc71'], [0.5, '#f39c12'], [1, '#e74c3c']],
                showscale=False,
                line=dict(color='white', width=2)
            ),
            hovertemplate=f'{kri_label}<br>%{{x}}: %{{y:.2f}}<extra></extra>'
        ))
    
    fig.update_layout(
        title="Key Risk Indicators Across Scenarios<br><sub>Color intensity indicates risk severity</sub>",
        xaxis_title="",
        yaxis_title="KRI Value",
        barmode='group',
        bargap=0.15,
        bargroupgap=0.1,
        legend=dict(
            orientation="v",
            yanchor="top",
            y=0.98,
            xanchor="right",
            x=0.98,
            bgcolor="rgba(255,255,255,0.95)",
            bordercolor="#cccccc",
            borderwidth=2,
            font=dict(size=11)
        ),
        margin=dict(l=70, r=30, t=90, b=70),
        plot_bgcolor='#fafafa',
        paper_bgcolor='white',
        height=450,
        font=dict(family="Arial", size=12)
    )
    
    fig.update_xaxes(
        showgrid=False,
        tickfont=dict(size=12, family="Arial Black")
    )
    fig.update_yaxes(
        showgrid=True,
        gridwidth=1,
        gridcolor='#e0e0e0',
        zeroline=True,
        zerolinewidth=2,
        zerolinecolor='#cccccc'
    )
    
    return fig


@app.callback(
    Output('scenario-comparison-distribution', 'figure'),
    Input('data-store', 'data')
)
def update_scenario_distribution(data):
    """Update probability distribution across scenarios with violin plots."""
    if data_cache['scenario_results'] is None:
        fetch_and_process_data()
    
    scenario_results = data_cache['scenario_results']
    
    # Calculate average default rate for each scenario
    scenarios = ['baseline', 'recession', 'rate_shock', 'credit_crisis']
    scenario_labels = ['Baseline', 'Recession', 'Rate Shock', 'Credit Crisis']
    
    # Create violin plot showing distribution
    fig = go.Figure()
    
    colors_scenario = ['#2ecc71', '#e74c3c', '#f39c12', '#3498db']
    
    for idx, (scenario_name, label) in enumerate(zip(scenarios, scenario_labels)):
        if scenario_name in scenario_results and scenario_results[scenario_name] is not None:
            sim_results = scenario_results[scenario_name]['simulation']
            if 'default_rate' in sim_results.columns:
                default_data = sim_results['default_rate'] * 100
                
                # Add violin plot
                fig.add_trace(go.Violin(
                    y=default_data,
                    name=label,
                    box_visible=True,
                    meanline_visible=True,
                    fillcolor=colors_scenario[idx],
                    opacity=0.7,
                    line_color='white',
                    marker=dict(
                        line=dict(color='white', width=1)
                    ),
                    hovertemplate=f'{label}<br>Default Rate: %{{y:.2f}}%<extra></extra>'
                ))
    
    fig.update_layout(
        title="Default Rate Distribution by Scenario<br><sub>Violin plots show full probability distribution with mean and quartiles</sub>",
        yaxis_title="Default Rate (%)",
        xaxis_title="",
        showlegend=False,
        margin=dict(l=70, r=30, t=90, b=70),
        plot_bgcolor='#fafafa',
        paper_bgcolor='white',
        height=450,
        font=dict(family="Arial", size=12)
    )
    
    fig.update_xaxes(
        showgrid=False,
        tickfont=dict(size=12, family="Arial Black")
    )
    fig.update_yaxes(
        showgrid=True,
        gridwidth=1,
        gridcolor='#e0e0e0',
        zeroline=True,
        zerolinewidth=2,
        zerolinecolor='#cccccc'
    )
    
    fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='#e0e0e0')
    
    return fig


@app.callback(
    Output('scenario-risk-metrics', 'children'),
    Input('data-store', 'data')
)
def update_scenario_risk_metrics(data):
    """Update scenario-conditional risk metrics table."""
    if data_cache['scenario_results'] is None:
        fetch_and_process_data()
    
    scenario_results = data_cache['scenario_results']
    
    scenarios = ['baseline', 'recession', 'rate_shock', 'credit_crisis']
    scenario_labels = ['Baseline', 'Recession', 'Rate Shock', 'Credit Crisis']
    
    rows = []
    
    for scenario_name, label in zip(scenarios, scenario_labels):
        if scenario_name not in scenario_results or scenario_results[scenario_name] is None:
            continue
        
        sim_results = scenario_results[scenario_name]['simulation']
        kris = scenario_results[scenario_name]['kris']
        
        # Calculate stress metrics
        if 'default_rate' in sim_results.columns:
            default_rates = sim_results['default_rate'] * 100
            mean_default = default_rates.mean()
            var_95 = np.percentile(default_rates, 95)  # Stress VaR
            tail_risk = default_rates[default_rates > var_95].mean()  # Conditional tail expectation
        else:
            mean_default = 0
            var_95 = 0
            tail_risk = 0
        
        # Get key KRIs
        loan_default = kris.get('loan_default_rate', 0)
        portfolio_vol = kris.get('portfolio_volatility', 0)
        lcr = kris.get('liquidity_coverage_ratio', 0)
        
        row = html.Tr([
            html.Td(label, style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'fontWeight': 'bold'}),
            html.Td(f"{mean_default:.2f}%", style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'textAlign': 'right'}),
            html.Td(f"{var_95:.2f}%", style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'textAlign': 'right'}),
            html.Td(f"{tail_risk:.2f}%", style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'textAlign': 'right'}),
            html.Td(f"{loan_default:.2f}%", style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'textAlign': 'right'}),
            html.Td(f"{portfolio_vol:.2f}%", style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'textAlign': 'right'}),
            html.Td(f"{lcr:.2f}", style={'padding': '12px', 'borderBottom': '1px solid #dee2e6', 'textAlign': 'right'})
        ])
        rows.append(row)
    
    return html.Table([
        html.Thead(html.Tr([
            html.Th('Scenario', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'left'}),
            html.Th('Mean Default Rate', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'right'}),
            html.Th('Stress VaR (95%)', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'right'}),
            html.Th('Tail Risk (CVaR)', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'right'}),
            html.Th('Loan Default Rate', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'right'}),
            html.Th('Portfolio Volatility', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'right'}),
            html.Th('Liquidity Ratio', style={'padding': '12px', 'borderBottom': '2px solid #dee2e6', 'textAlign': 'right'})
        ])),
        html.Tbody(rows)
    ], style={'width': '100%', 'borderCollapse': 'collapse'})


@app.callback(
    Output('download-data', 'data'),
    [Input('export-csv-button', 'n_clicks'),
     Input('export-excel-button', 'n_clicks'),
     Input('export-json-button', 'n_clicks')],
    prevent_initial_call=True
)
def export_data(csv_clicks, excel_clicks, json_clicks):
    """Export dashboard data in various formats."""
    ctx = dash.callback_context
    
    if not ctx.triggered:
        return None
    
    button_id = ctx.triggered[0]['prop_id'].split('.')[0]
    
    if data_cache['kris'] is None:
        return None
    
    # Prepare export data
    kris = data_cache['kris']
    risk_levels = data_cache['risk_levels']
    economic_data = data_cache['economic_data']
    forecasts = data_cache['forecasts']
    
    # Create comprehensive export DataFrame
    export_data = {
        'KRI_Name': [],
        'Category': [],
        'Current_Value': [],
        'Risk_Level': [],
        'Type': []
    }
    
    for kri_name, value in kris.items():
        kri_def = kri_registry.get_kri(kri_name)
        risk_level = risk_levels[kri_name]
        
        export_data['KRI_Name'].append(kri_name)
        export_data['Category'].append(kri_def.category.value)
        export_data['Current_Value'].append(value)
        export_data['Risk_Level'].append(risk_level.value)
        export_data['Type'].append('Leading' if kri_def.is_leading else 'Lagging')
    
    df = pd.DataFrame(export_data)
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    if button_id == 'export-csv-button':
        return dcc.send_data_frame(df.to_csv, f"risk_dashboard_{timestamp}.csv", index=False)
    
    elif button_id == 'export-excel-button':
        # Create Excel with multiple sheets
        import io
        output = io.BytesIO()
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='KRIs', index=False)
            economic_data.to_excel(writer, sheet_name='Economic_Data')
            forecasts.to_excel(writer, sheet_name='Forecasts')
        
        output.seek(0)
        return dcc.send_bytes(output.getvalue(), f"risk_dashboard_{timestamp}.xlsx")
    
    elif button_id == 'export-json-button':
        # Create comprehensive JSON export
        json_data = {
            'timestamp': timestamp,
            'kris': {k: float(v) for k, v in kris.items()},
            'risk_levels': {k: v.value for k, v in risk_levels.items()},
            'economic_data': economic_data.tail(12).to_dict(orient='records'),
            'forecasts': forecasts.to_dict(orient='records')
        }
        
        import json
        json_str = json.dumps(json_data, indent=2)
        return dict(content=json_str, filename=f"risk_dashboard_{timestamp}.json")
    
    return None


if __name__ == '__main__':
    logger.info("Starting Risk Forecasting Dashboard...")
    logger.info(f"Dashboard will be available at: http://localhost:{settings.dashboard_port}")
    
    # Initial data load
    fetch_and_process_data()
    
    # Run server
    app.run(debug=True, host='0.0.0.0', port=settings.dashboard_port)
